###################################################
Определить стандартные действия для ИИ:
+	Move
	Health
	Attack

-j2

Разделить инициализацию.

Обращаться к локалМап. Фулл мап - запретить для не Мап.


Запилить правильно ( "инкапсулировано" ) ресурсы на карте!

Вынести инициализацию дерева вне ядра, т.к. зависит от заданных юзером классов.

Сделать что ли Strategix_Forward.h ???

Карты держать локальные для игрока и одну для Ядра, которая изменяется постредством триггеров на локальных "проекциях". 

В С++ нет виртуального конструктора копирования ????? ( TechTree::init() )




****

ObjectTitle - каваизировать!

может вместо list заюзать односвязный список для Units ?


поубирать деструкторы из срр файлов! Вместо них {} в .h для =0, и удалить ваще для остальных.

сделать Enti другом Unit, и закрыть все методы Unit нафиг (инкапсуляция типо) ?

подумать как будут выходить предупреждения о невозможности действия!

Добавить у Enti область постройки( чтобы здания др-на-др не наезжали )



--------------------------------------------
make, g++ options -j2,... ?

precompiled headers для стандартной библиотеки КАК ?

Разобраццо с реализацией дерева в бусте в венде. (чёзанах, можт буст грейдануть до 1.44?)

Поддвижок ИИ сделать как можно более "отдельным" чтобы можно было подцепить его к другому ядру.
Иметь в виду, что ИИ может быть осуществлён не только через С++. (Lua например) Т.е. продумать правильный интерфейс подключения ИИ.

template<typename T>
		std::ostream& operator<<(std::ostream& o, const TRect<T>& r)
		{
			o << "TRect<>(l:" << r.left << ", t:" << r.top << ", r:" << r.right << ", b:" << r.bottom << ")";
			return o;
		}

****************
Колбэки чисто через указатели на методы организовать невозможно, т.к. не известен класс которому возвращать.
По той же причине нельзя через шаблоны это сделать.
Похоже единственный способ организовать колбэк в С++ из библиотеки - юзать наследование от библиотечного класса.
****************
Полная спецификация шаблона аналогична реализации обычной функции.
Поэтому не может быть в .h файле!!!
****************
Не делать каждый объект наследником FrameListener! Ибо глюки с удалением в v.<7.1 по крайней мере. Лучше один FrameListener на все объекты.
	// removeFrameListener must be earier than destructor on one frame
	// elsewise there will be try to render deleted object!!!
	// Solution is to add this object to deletion list, called after one frame.
	// Or to hit on the head someone from OGRE developers :)
****************
Если и буду писать интерфейсы с CEGUI, то уже с версией ≥7, ибо другие не отрисовывают(
и не в Генте, ибо там зависимости для ≥7 версии видимо не те.
****************