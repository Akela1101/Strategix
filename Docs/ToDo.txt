#######
Не делать каждый объект наследником FrameListener! Ибо глюки с удалением в v.<7.1 по крайней мере. Лучше один FrameListener на все объекты.
	// removeFrameListener must be earier than destructor on one frame
	// elsewise there will be try to render deleted object!!!
	// Solution is to add this object to deletion list, called after one frame.
	// Or to hit on the head someone from OGRE developers :)

Если и буду писать интерфейсы с CEGUI, то уже с версией ≥7, ибо другие не отрисовывают(
и не в Генте, ибо там зависимости для ≥7 версии видимо не те.

Поддвижок ИИ сделать как можно более "отдельным" чтобы можно было подцепить его к другому ядру.
Иметь в виду, что ИИ может быть осуществлён не только через С++. (Lua например) Т.е. продумать правильный интерфейс подключения ИИ.


==========
+ Слияние Кода из Example со своим.

+ Уменьшение зависимостей путём замены определений классов их объявлениями. 

+ Реорганизация игрового цикла. Из каждого объекта Tick() в общий цикл.

+ Замутить действия Feature со встроенными чисто виртуальными колбеками. 
	И определить стандартные действия для ИИ:
	Move
	Health
	Attack

+ Задавать масштаб координат и делать неявный перевод из одних в другие.

+ Задать интерфейсы для основных классов ядра и посредством их управлять.

Вынести инициализацию дерева вне ядра, т.к. зависит от заданных юзером классов.

Сделать что ли Strategix_Forward.h ???

Карты держать локальные для игрока и одну для Ядра, которая изменяется постредством триггеров на локальных "проекциях". 

ObjectTitle - каваизировать!

может вместо list заюзать односвязный список для Units ?


поубирать деструкторы из срр файлов! Вместо них {} в .h для =0, и удалить ваще для остальных.

сделать Enti другом Unit, и закрыть все методы Unit нафиг (инкапсуляция типо) ?

подумать как будут выходить предупреждения о невозможности действия!


--------------------------------------------
make, g++ options -j2,... ?

precompiled headers для стандартной библиотеки КАК ?

Разобраццо с реализацией дерева в бусте в венде. (чёзанах, можт буст грейдануть до 1.44?)



***
Колбэки чисто через указатели на методы организовать невозможно, т.к. не известен класс которому возвращать.
По той же причине нельзя через шаблоны это сделать.
Похоже единственный способ организовать колбэк в С++ из библиотеки - юзать наследование от библиотечного класса.
***
Полная спецификация шаблона аналогична реализации обычной функции.
Поэтому не может быть в .h файле!!!
***