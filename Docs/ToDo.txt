###################################################
Получать действия по имени, а не по функции в Enti!!!!! (думать о добавлении новых)

Раскоментить все строчи из TTBuilder и проверить на венде для boost 1.46

Вынести класс карты как общий для всех проектов.

Поправить редактор карт. Добавить рабочего и иконку золота. Добавить считывание и запись версии
Использовать один класс Map для всех приложений юзающих карту!!!

Запилить классы ресурсов нормально!

Проверить как ставится и изчезает меш ресурса ( да и остальные тоже )

Может radius (сбора, атаки) засунуть в ПоискПути?

Привести в порядок Логи!!!!

KernelBase constructor с параметрами вместо Configure, чтобы не проверять выполнилась ли она.

Разделить инициализацию.

mDebugOverlay - заработать

Обращаться к локалМап. Фулл мап - запретить для не Мап.

Почему бы AnimationName не передавать через xml файл?

Сделать прокрутку Entity когда они перекрывают друг друга и нельзя выбрать нижний мышкой.

Запилить правильно ( "инкапсулировано" ) ресурсы на карте!

Вынести инициализацию дерева вне ядра, т.к. зависит от заданных юзером классов.

Сделать что ли Strategix_Forward.h ???

Карты держать локальные для игрока и одну для Ядра, которая изменяется постредством триггеров на локальных "проекциях". 

Скрыть все открытые методы, которые не будет юзать юзер, но юзаются внутри самой бибиотеки. 
(Tick, AssignTickFeature, ...) (например сделать friend класс....)

перейти на c++ox и запилить обращение к map через at. Либо самому запилить это через find.

ObjectTitle - каваизировать!

может вместо list заюзать односвязный список для Units ?

поубирать деструкторы из срр файлов! Вместо них {} в .h для =0, и удалить ваще для остальных.

сделать Enti другом Unit, и закрыть все методы Unit нафиг (инкапсуляция типо) ?

подумать как будут выходить предупреждения о невозможности действия!

Добавить у Enti область постройки( чтобы здания др-на-др не наезжали )

Определить стандартные действия для ИИ:
	Move
	Collect
	Health
	Attack
	Repair

--------------------------------------------

precompiled headers для стандартной библиотеки КАК ?

Поддвижок ИИ сделать как можно более "отдельным" чтобы можно было подцепить его к другому ядру.
Иметь в виду, что ИИ может быть осуществлён не только через С++. (Lua например) Т.е. продумать правильный интерфейс подключения ИИ.

Добавить операторы для игровых типов:
template<typename T>
std::ostream& operator<<(std::ostream& o, const TRect<T>& r)
{
	o << "TRect<>(l:" << r.left << ", t:" << r.top << ", r:" << r.right << ", b:" << r.bottom << ")";
	return o;
}

****************
Полная спецификация шаблона аналогична реализации обычной функции.
Поэтому не может быть в .h файле!!! (в GCC. в MSCC может)

****************
Не делать каждый объект наследником FrameListener! Ибо глюки с удалением в v.<=7.1 по крайней мере. Лучше один FrameListener на все объекты.
	// removeFrameListener must be earier than destructor on one frame
	// elsewise there will be try to render deleted object!!!
	// Solution is to add this object to deletion list, called after one frame.
	// Or to hit on the head someone from OGRE developers :)

****************